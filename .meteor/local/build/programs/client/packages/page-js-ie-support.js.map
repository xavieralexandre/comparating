)]}'
{"version":3,"file":"/packages/page-js-ie-support.js","sources":["page-js-ie-support/page-js/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,a;;AAEA,K;AACA,8B;AACA,K;;AAEA,sB;;AAEA,K;AACA,e;AACA,K;;AAEA,gB;;AAEA,K;AACA,kB;AACA,K;;AAEA,c;;AAEA,K;AACA,kC;AACA,uF;AACA,K;AACA,qD;;AAEA,K;AACA,0C;AACA,wC;AACA,I;AACA,gB;AACA,qB;AACA,qC;AACA,mD;AACA,gC;AACA,c;AACA,I;AACA,kC;AACA,4B;AACA,gB;AACA,K;;AAEA,2B;AACA,iB;AACA,oC;AACA,6B;AACA,K;;AAEA,qC;AACA,kC;AACA,kC;AACA,kD;AACA,4D;AACA,O;AACA,+B;AACA,yC;AACA,0B;AACA,sB;AACA,Y;AACA,uB;AACA,K;AACA,G;;AAEA,K;AACA,wB;AACA,K;;AAEA,sB;;AAEA,K;AACA,mC;AACA,I;AACA,yB;AACA,gB;AACA,K;;AAEA,6B;AACA,2C;AACA,gB;AACA,I;;AAEA,K;AACA,mC;AACA,I;AACA,a;AACA,I;AACA,6C;AACA,4C;AACA,oD;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,iC;AACA,4B;AACA,wB;AACA,mB;AACA,qD;AACA,6E;AACA,sE;AACA,0B;AACA,4E;AACA,I;;AAEA,K;AACA,8C;AACA,I;AACA,gB;AACA,K;;AAEA,yB;AACA,oB;AACA,4C;AACA,gD;AACA,I;;AAEA,K;AACA,8C;AACA,I;AACA,yB;AACA,0B;AACA,8B;AACA,sB;AACA,gB;AACA,K;;AAEA,8C;AACA,uC;AACA,+C;AACA,wC;AACA,e;AACA,I;;AAEA,K;AACA,iD;AACA,I;AACA,yB;AACA,0B;AACA,sB;AACA,gB;AACA,K;;AAEA,uD;AACA,uC;AACA,oB;AACA,0C;AACA,qC;AACA,e;AACA,e;AACA,I;;AAEA,K;AACA,8B;AACA,I;AACA,wB;AACA,iB;AACA,K;;AAEA,gC;AACA,c;;AAEA,qB;AACA,mC;AACA,qC;AACA,oB;AACA,K;;AAEA,W;AACA,I;;AAEA,K;AACA,+C;AACA,kD;AACA,gD;AACA,I;AACA,yB;AACA,iB;AACA,K;;AAEA,2B;AACA,yE;AACA,gB;AACA,yB;AACA,wC;AACA,G;;AAEA,K;AACA,yC;AACA,wD;AACA,I;AACA,yB;AACA,0B;AACA,gB;AACA,K;;AAEA,iC;AACA,sE;AACA,8B;AACA,8B;AACA,8C;AACA,gC;AACA,6B;AACA,2B;AACA,mD;AACA,iD;AACA,qB;AACA,G;;AAEA,K;AACA,sB;AACA,K;;AAEA,yB;;AAEA,K;AACA,gB;AACA,I;AACA,iB;AACA,K;;AAEA,2C;AACA,kE;AACA,I;;AAEA,K;AACA,4B;AACA,I;AACA,gB;AACA,K;;AAEA,sC;AACA,qE;AACA,I;;AAEA,K;AACA,mD;AACA,+C;AACA,I;AACA,a;AACA,I;AACA,oD;AACA,mE;AACA,I;AACA,yB;AACA,6B;AACA,iB;AACA,K;;AAEA,iC;AACA,4B;AACA,qB;AACA,wB;AACA,mC;AACA,sB;AACA,yB;AACA,wB;AACA,G;;AAEA,K;AACA,oB;AACA,K;;AAEA,qB;;AAEA,K;AACA,iC;AACA,+B;AACA,I;AACA,yB;AACA,uB;AACA,gB;AACA,K;;AAEA,4C;AACA,oB;AACA,+B;AACA,iE;AACA,a;AACA,K;AACA,I;;AAEA,K;AACA,8C;AACA,uB;AACA,I;AACA,yB;AACA,0B;AACA,sB;AACA,iB;AACA,K;;AAEA,iD;AACA,wB;AACA,mC;AACA,2D;AACA,uC;;AAEA,yB;;AAEA,mD;AACA,4B;;AAEA,uC;AACA,kC;AACA,e;;AAEA,gB;AACA,yD;AACA,4B;AACA,gB;AACA,c;AACA,yB;AACA,O;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,qC;AACA,oC;AACA,I;AACA,qC;AACA,uC;AACA,4C;AACA,yB;AACA,I;AACA,uC;AACA,yB;AACA,gC;AACA,6B;AACA,qB;AACA,iB;AACA,K;;AAEA,wD;AACA,4C;AACA,iE;AACA,e;AACA,iC;AACA,+B;AACA,0G;AACA,wD;AACA,4B;AACA,iB;AACA,mC;AACA,iB;AACA,mC;AACA,qF;AACA,6B;AACA,Q;AACA,kC;AACA,8B;AACA,8D;AACA,I;;AAEA,K;AACA,8B;AACA,K;;AAEA,0B;AACA,kB;AACA,8B;AACA,kC;AACA,K;AACA,G;;AAEA,K;AACA,2B;AACA,K;;AAEA,uB;AACA,0B;AACA,qD;AACA,mC;AACA,sC;AACA,wD;AACA,0C;AACA,uB;AACA,uC;AACA,I;AACA,yE;AACA,6E;AACA,6B;AACA,wB;AACA,wB;AACA,I;AACA,0D;AACA,kC;AACA,oB;AACA,kC;AACA,qC;AACA,kE;AACA,oB;AACA,G;;AAEA,K;AACA,kB;AACA,K;;AAEA,qB;AACA,0B;AACA,0B;AACA,qB;AACA,qB;AACA,G;AACA,E;AACA,K;AACA,wC;AACA,K;;AAEA,6B;AACA,8D;AACA,qD;AACA,qC;AACA,G;AACA,E;AACA,K;AACA,mC;AACA,K;;AAEA,qC;AACA,gC;AACA,6C;AACA,a;AACA,wC;AACA,M;AACA,I;;AAEA,wC;AACA,mC;AACA,gD;AACA,a;AACA,wC;AACA,M;AACA,I;;AAEA,K;AACA,mB;AACA,K;;AAEA,qC;AACA,uB;AACA,U;AACA,0B;AACA,G;;AAEA,K","sourcesContent":[";(function(){\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n  var location = history.location || window.location;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page();\n   *\n   * @param {String|Function} path\n   * @param {Function} fn...\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' == typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' == typeof fn) {\n      var route = new Route(path);\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n    // show <path> with [state]\n    } else if ('string' == typeof path) {\n      page.show(path, fn);\n    // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {String} path\n   * @api public\n   */\n\n  page.base = function(path){\n    if (0 == arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options){\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false !== options.popstate) addEvent(window, 'popstate', onpopstate);\n    if (false !== options.click) addEvent(document, 'click', onclick);\n    if (!dispatch) return;\n    page.replace(location.pathname + location.search, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function(){\n    running = false;\n    removeEvent(document, 'click', onclick);\n    removeEvent(window, 'popstate', onpopstate);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @param {Boolean} dispatch\n   * @return {Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch){\n    var ctx = new Context(path, state);\n    if (false !== dispatch) page.dispatch(ctx);\n    if (!ctx.unhandled) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @return {Context}\n   * @api public\n   */\n\n  page.replace = function(path, state, init, dispatch){\n    var ctx = new Context(path, state);\n    ctx.init = init;\n    if (null == dispatch) dispatch = true;\n    if (dispatch) page.dispatch(ctx);\n    ctx.save();\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Object} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx){\n    var i = 0;\n\n    function next() {\n      var fn = page.callbacks[i++];\n      if (!fn) return unhandled(ctx);\n      fn(ctx, next);\n    }\n\n    next();\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  function unhandled(ctx) {\n    if (location.pathname + location.search == ctx.canonicalPath) return;\n    page.stop();\n    ctx.unhandled = true;\n    window.location = ctx.canonicalPath;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' == path[0] && 0 != path.indexOf(base)) path = base + path;\n    var i = path.indexOf('?');\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? path.slice(i + 1) : '';\n    this.pathname = ~i ? path.slice(0, i) : path;\n    this.params = [];\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function(){\n    history.pushState(this.state, this.title, this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function(){\n    history.replaceState(this.state, this.title, this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {Object} options.\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(path\n      , this.keys = []\n      , options.sensitive\n      , options.strict);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn){\n    var self = this;\n    return function(ctx, next){\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    }\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {Array} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params){\n    var keys = this.keys\n      , qsIndex = path.indexOf('?')\n      , pathname = ~qsIndex ? path.slice(0, qsIndex) : path\n      , m = this.regexp.exec(pathname);\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n\n      var val = 'string' == typeof m[i]\n        ? decodeURIComponent(m[i])\n        : m[i];\n\n      if (key) {\n        params[key.name] = undefined !== params[key.name]\n          ? params[key.name]\n          : val;\n      } else {\n        params.push(val);\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Normalize the given path string,\n   * returning a regular expression.\n   *\n   * An empty array should be passed,\n   * which will contain the placeholder\n   * key names. For example \"/user/:id\" will\n   * then contain [\"id\"].\n   *\n   * @param  {String|RegExp|Array} path\n   * @param  {Array} keys\n   * @param  {Boolean} sensitive\n   * @param  {Boolean} strict\n   * @return {RegExp}\n   * @api private\n   */\n\n  function pathtoRegexp(path, keys, sensitive, strict) {\n    if (path instanceof RegExp) return path;\n    if (path instanceof Array) path = '(' + path.join('|') + ')';\n    path = path\n      .concat(strict ? '' : '/?')\n      .replace(/\\/\\(/g, '(?:/')\n      .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n        keys.push({ name: key, optional: !! optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n          + (optional || '');\n      })\n      .replace(/([\\/.])/g, '\\\\$1')\n      .replace(/\\*/g, '(.*)');\n    return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n  };\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  function onpopstate(e) {\n    if (e.state) {\n      var path = e.state.path;\n      page.replace(path, e.state);\n    }\n  }\n\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n    if (!which(e)) return;\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n    var el = e.target || e.srcElement;\n    while (el && 'A' != el.nodeName) el = el.parentNode;\n    if (!el || 'A' != el.nodeName) return;\n    var href = el.href;\n    var path = el.pathname + el.search;\n    \n    // XXX: I don't think this hack will work in earlier versions of IE, \n    // fix to properly parse out path from href; I'm just putting this in for\n    // now to see if it works\n    if (path[0] !== '/')\n      path = '/' + path;\n    \n    if (el.hash || '#' == el.getAttribute('href')) return;\n    if (!sameOrigin(href)) return;\n    var orig = path;\n    path = path.replace(base, '');\n    if (base && orig == path) return;\n    e.preventDefault ? e.preventDefault() : e.returnValue = false;\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null == e.which\n      ? e.button == 0\n      : e.which == 1;\n  }\n  \n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return 0 == href.indexOf(origin);\n  }\n  \n  /**\n   * Basic cross browser event code\n   */\n\n   function addEvent(obj, type, fn) {\n     if (obj.addEventListener) {\n       obj.addEventListener(type, fn, false);\n     } else {\n       obj.attachEvent('on' + type, fn);\n     }\n   }\n\n   function removeEvent(obj, type, fn) {\n     if (obj.removeEventListener) {\n       obj.removeEventListener(type, fn, false);\n     } else {\n       obj.detachEvent('on' + type, fn);\n     }\n   }\n\n  /**\n   * Expose `page`.\n   */\n\n  if ('undefined' == typeof module) {\n    window.page = page;\n  } else {\n    module.exports = page;\n  }\n\n})();\n"]}