)]}'
{"version":3,"file":"/packages/router.js","sources":["router/lib/router_client.js","router/lib/router_helpers.js","router/lib/router_common.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,a;AACA,2B;AACA,sB;AACA,+B;AACA,I;AACA,uB;AACA,6B;AACA,2C;AACA,I;AACA,0B;AACA,G;AACA,E;AACA,wB;AACA,2D;AACA,oB;AACA,Y;AACA,I;AACA,qD;AACA,+D;AACA,0D;AACA,yE;AACA,+E;AACA,sD;AACA,mD;AACA,8C;AACA,uD;AACA,S;AACA,I;AACA,M;AACA,oB;AACA,iC;AACA,uC;AACA,M;AACA,+B;AACA,mE;AACA,M;AACA,wD;AACA,2D;AACA,M;AACA,G;AACA,E;AACA,mD;AACA,oB;AACA,I;AACA,iD;AACA,0C;AACA,8B;AACA,S;AACA,Y;AACA,mD;AACA,6D;AACA,kC;AACA,O;AACA,M;AACA,sE;AACA,qD;AACA,kC;AACA,O;AACA,6D;AACA,M;AACA,2D;AACA,4D;AACA,4F;AACA,U;AACA,K;AACA,G;AACA,E;AACA,4D;AACA,oB;AACA,yD;AACA,I;AACA,sE;AACA,+B;AACA,a;AACA,I;AACA,wE;AACA,uE;AACA,8C;AACA,mC;AACA,I;AACA,0D;AACA,gC;AACA,uD;AACA,mD;AACA,K;AACA,I;AACA,4C;AACA,wE;AACA,sE;AACA,K;AACA,G;AACA,E;AACA,sC;AACA,gC;AACA,sB;AACA,G;AACA,E;AACA,wC;AACA,kB;AACA,0B;AACA,yC;AACA,kB;AACA,iD;AACA,M;AACA,0D;AACA,sD;AACA,K;AACA,I;AACA,e;AACA,G;AACA,E;AACA,mD;AACA,wC;AACA,G;AACA,E;AACA,sB;AACA,K;AACA,4C;AACA,4C;AACA,2D;AACA,kD;AACA,+D;AACA,mE;AACA,mC;AACA,4C;AACA,qD;AACA,oB;AACA,I;AACA,2B;AACA,mD;AACA,kC;AACA,S;AACA,K;AACA,I;AACA,4B;AACA,wB;AACA,kD;AACA,oC;AACA,sD;AACA,wC;AACA,I;AACA,sC;AACA,G;AACA,E;AACA,iD;AACA,yB;AACA,8C;AACA,6B;AACA,G;AACA,E;AACA,8B;AACA,mD;AACA,oB;AACA,iE;AACA,4C;AACA,a;AACA,G;AACA,E;AACA,4D;AACA,0D;AACA,qB;AACA,sB;AACA,2C;AACA,+B;AACA,+C;AACA,K;AACA,U;AACA,gB;AACA,8C;AACA,Y;AACA,kB;AACA,K;AACA,G;AACA,E;AACA,iE;AACA,kD;AACA,iD;AACA,E;AACA,+B;AACA,yC;AACA,K;;;;;;;;;;;;;;;;;;ACpLA,wC;AACA,mE;AACA,2B;AACA,kC;AACA,I;AACA,uB;AACA,6D;AACA,K;AACA,E;AACA,uD;AACA,gC;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;ACZA,a;AACA,4D;AACA,I;AACA,iE;AACA,I;AACA,K;AACA,kE;AACA,+C;AACA,I;AACA,a;AACA,I;AACA,oD;AACA,mE;AACA,I;AACA,yB;AACA,2B;AACA,6B;AACA,iB;AACA,K;;AAEA,yD;AACA,4B;AACA,qB;AACA,yB;AACA,mC;AACA,sB;AACA,yB;AACA,wB;AACA,G;;AAEA,K;AACA,oE;AACA,uB;AACA,I;AACA,yB;AACA,2B;AACA,0B;AACA,sB;AACA,iB;AACA,K;;AAEA,uE;AACA,mC;AACA,I;AACA,0E;;AAEA,qB;AACA,gC;AACA,wD;AACA,mC;AACA,E;AACA,yB;;AAEA,mD;AACA,4B;;AAEA,uC;AACA,kC;AACA,e;;AAEA,gB;AACA,yD;AACA,4B;AACA,gB;AACA,c;AACA,yB;AACA,O;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,qC;AACA,oC;AACA,I;AACA,qC;AACA,uC;AACA,4C;AACA,yB;AACA,I;AACA,uC;AACA,yB;AACA,gC;AACA,6B;AACA,qB;AACA,iB;AACA,K;;AAEA,wD;AACA,4C;AACA,iE;AACA,e;AACA,iC;AACA,+B;AACA,iC;AACA,0G;AACA,wD;AACA,4B;AACA,iB;AACA,mC;AACA,iB;AACA,mC;AACA,qF;AACA,6B;AACA,Q;AACA,kC;AACA,mC;AACA,8B;AACA,I;AACA,8D;AACA,I;AACA,E;AACA,sB;AACA,E;AACA,kE;AACA,E;AACA,K;AACA,6E;AACA,gC;AACA,I;AACA,6E;AACA,I;AACA,2B;AACA,mE;AACA,kB;;AAEA,Y;AACA,yD;AACA,sD;AACA,4B;AACA,I;AACA,sE;AACA,oB;AACA,yB;AACA,c;AACA,yB;AACA,Q;AACA,yE;AACA,iE;AACA,O;AACA,iD;AACA,I;AACA,4B;AACA,I;AACA,8D;AACA,qC;AACA,uC;AACA,c;AACA,M;AACA,8B;AACA,2B;AACA,U;AACA,sB;AACA,M;AACA,yC;AACA,M;AACA,I;AACA,mD;;AAEA,gB;AACA,G;AACA,K","sourcesContent":["(function() {\n  var Router = function() {\n    this._page = null;\n    this._autorunHandle = null;\n    \n    this._filters = {};\n    this._activeFilters = [];\n    this._pageDeps = new Deps.Dependency();\n    \n    this.namedRoutes = {};\n  }\n  \n  // internal, don't use\n  Router.prototype._setPageFn = function(pageFn, context) {\n    var self = this,\n\t\tinterrupt;\n    \n    // the current function that generates self._page\n    // we could just store pageFn and call it everytime someone\n    // calls Meteor.Router.page(), but this would lead to \n    // the routing function getting called multiple times, which could be\n    // unexpected if it has side effects. This is essentially a memoize pattern\n    self._autorunHandle && self._autorunHandle.stop();\n    self._autorunHandle = Deps.autorun(function() {\n      interrupt = self.beforeRouting(context);\n\t  if (interrupt != undefined && interrupt === false) {\n\t\treturn;\n\t  }\n      \n      var args = [];\n      for (key in context.params)\n        args.push(context.params[key]);\n      \n      var oldPage = self._page;\n      self._page = self._applyFilters(pageFn.apply(context, args));\n      \n      // no need to invalidate if .page() hasn't changed\n      (oldPage !== self._page) && self._pageDeps.changed();\n    })\n  }\n  \n  Router.prototype.add = function(path, endpoint) {\n    var self = this;\n    \n    if (_.isObject(path) && ! _.isRegExp(path)) {\n      _.each(path, function(endpoint, p) {\n        self.add(p, endpoint);\n      });\n    } else {\n      // '/foo' -> 'bar' <==> '/foo' => {to: 'bar'}\n      if (! _.isObject(endpoint) || _.isFunction(endpoint)) {\n        endpoint = {to: endpoint};\n      }\n      \n      // route name defaults to template name (unless it's functional)\n      if (! endpoint.as && _.isString(endpoint.to)) {\n        endpoint.as = endpoint.to;\n      }\n      endpoint.as && self._setUpNamedRoute(endpoint.as, path)\n      \n      page(path, _.bind(self._setPageFn, self, function() {\n        endpoint.and && endpoint.and.apply(this, arguments);\n        return _.isFunction(endpoint.to) ? endpoint.to.apply(this, arguments) : endpoint.to;\n      }));\n    }\n  }\n  \n  Router.prototype._setUpNamedRoute = function(name, path) {\n    var self = this;\n    var pathName = name + 'Path', urlName = name + 'Url';\n    \n    // XXX: I'm not sure there shouldn't be some way to overwrite them\n    if (self.namedRoutes[name])\n      return;\n    \n    // XXX: there is some duplication here because page creates it's own\n    // route object, but ours has a few extra bits that their's doesn't\n    var route = new Meteor.Router.Route(path);\n    self.namedRoutes[name] = route;\n    \n    self[pathName] = _.bind(route.pathWithContext, route);\n    self[urlName] = function() {\n      var path = self[pathName].apply(self, arguments);\n      return Meteor.absoluteUrl(path.substring(1));\n    }\n    \n    if (typeof Handlebars !== 'undefined') {\n      Handlebars.registerHelper(pathName, _.bind(self[pathName], self));\n      Handlebars.registerHelper(urlName, _.bind(self[urlName], self));\n    }\n  }\n  \n  Router.prototype.page = function() {\n    Deps.depend(this._pageDeps);\n    return this._page;\n  }\n  \n  Router.prototype.to = function(path) {\n    // named route\n    if (path[0] !== '/') {\n      var route = this.namedRoutes[path];\n      if (! route)\n        throw 'That named route does not exist!';\n      \n      var args = Array.prototype.slice.call(arguments, 1);\n      path = route.pathWithContext.apply(route, args);\n    }\n    \n    page(path);\n  }\n  \n  Router.prototype.filters = function(filtersMap) {\n    _.extend(this._filters, filtersMap);\n  }\n  \n  // call with one of:\n  // \n  //   Meteor.Router.filter('filter-name'); \n  //     - filter all pages with filter-name\n  //   Meteor.Router.filter('filter-name', {only: 'home'});\n  //     - filter the 'home' page with filter-name\n  //   Meteor.Router.filter('filter-name', {except: ['home']});\n  //     - filter all pages except the 'home' page with filter-name\n  //   Meteor.Router.filter(object)\n  //     -  a map of name: application pairs\n  Router.prototype.filter = function(name, options) {\n    var self = this;\n    \n    if (_.isObject(name)) {\n      return _.each(name, function(options, key) { \n        self.filter(key, options);\n      });\n    }\n    \n    options = options || {};\n    options.name = name;\n    if (options.only && ! _.isArray(options.only))\n      options.only = [options.only];\n    if (options.except && ! _.isArray(options.except))\n      options.except = [options.except];\n    \n    self._activeFilters.push(options);\n  }\n  \n  // Shouldn't need to use this, more for testing\n  // turn off all filters\n  Router.prototype.resetFilters = function() {\n    this._activeFilters = [];\n  }\n  \n  // run all filters over page\n  Router.prototype._applyFilters = function(page) {\n    var self = this;\n    return _.reduce(self._activeFilters, function(page, filter) {\n      return self._applyFilter(page, filter)\n    }, page);\n  }\n  \n  // run a single filter (first check only and except apply)\n  Router.prototype._applyFilter = function(page, filter) {\n    var apply = true;\n    if (filter.only) {\n      apply = _.include(filter.only, page);\n    } else if (filter.except) {\n      apply = ! _.include(filter.except, page);\n    }\n          \n    if (apply) {\n      return this._filters[filter.name](page);\n    } else {\n      return page;\n    }\n  }\n  \n  // set this to have a function run before each and every route.\n  // - the callback should take a context argument\n  Router.prototype.beforeRouting = function() {};\n  \n  Meteor.Router = new Router();\n  Meteor.startup(function() { page(); });\n}());","if (typeof Handlebars !== 'undefined') {\n  Handlebars.registerHelper('renderPage', function(name, options) {\n    if (! _.isString(name))\n      name = Meteor.Router.page();\n    \n    if (Template[name])\n      return new Handlebars.SafeString(Template[name](this));\n  });\n  \n  Handlebars.registerHelper('currentPage', function() {\n    return Meteor.Router.page();\n  });\n}\n","(function() {\n  // Route object taken from page.js, slightly stripped down\n  //\n  // Copyright (c) 2012 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\n  //\n  /**\n   * Initialize `Route` with the given HTTP `path`, HTTP `method`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {String} method\n   * @param {Object} options.\n   * @api private\n   */\n\n  Meteor.Router.Route = function(path, method, options) {\n    options = options || {};\n    this.path = path;\n    this.method = method;\n    this.regexp = pathtoRegexp(path\n      , this.keys = []\n      , options.sensitive\n      , options.strict);\n  }\n\n  /**\n   * Check if this route matches `path` and optional `method`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {String} method\n   * @param {Array} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Meteor.Router.Route.prototype.match = function(path, method, params){\n    var keys, qsIndex, pathname, m;\n    \n    if (this.method && this.method.toUpperCase() !== method) return false;\n\n    keys = this.keys;\n    qsIndex = path.indexOf('?');\n    pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n    m = this.regexp.exec(pathname);\n  \n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n\n      var val = 'string' == typeof m[i]\n        ? decodeURIComponent(m[i])\n        : m[i];\n\n      if (key) {\n        params[key.name] = undefined !== params[key.name]\n          ? params[key.name]\n          : val;\n      } else {\n        params.push(val);\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Normalize the given path string,\n   * returning a regular expression.\n   *\n   * An empty array should be passed,\n   * which will contain the placeholder\n   * key names. For example \"/user/:id\" will\n   * then contain [\"id\"].\n   *\n   * @param  {String|RegExp|Array} path\n   * @param  {Array} keys\n   * @param  {Boolean} sensitive\n   * @param  {Boolean} strict\n   * @return {RegExp}\n   * @api private\n   */\n\n  function pathtoRegexp(path, keys, sensitive, strict) {\n    if (path instanceof RegExp) return path;\n    if (path instanceof Array) path = '(' + path.join('|') + ')';\n    path = path\n      .concat(strict ? '' : '/?')\n      .replace(/\\/\\(/g, '(?:/')\n      .replace(/\\+/g, '__plus__')\n      .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n        keys.push({ name: key, optional: !! optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n          + (optional || '');\n      })\n      .replace(/([\\/.])/g, '\\\\$1')\n      .replace(/__plus__/g, '(.+)')\n      .replace(/\\*/g, '(.*)');\n    \n    return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n  };\n  \n  /// END Route object\n  \n  // Added by tom, lifted from mini-pages, with some modifications\n  \n  /**\n    Given a context object, returns a url path with the values of the context\n    object mapped over the path.\n    \n    Alternatively, supply the named parts of the paths as discrete arguments.\n    \n    @method pathWithContext\n    @param [context] {Object} An optional context object to use for\n    interpolation.\n\n    @example\n        // given a page with a path of \"/posts/:_id/edit\"\n        var path = page.pathWithContext({ _id: 123 });\n        // > /posts/123/edit\n  */\n  Meteor.Router.Route.prototype.pathWithContext = function (context) {\n    var self = this,\n        path = self.path,\n        parts,\n        args = arguments;\n        \n    /* get an array of keys from the path to replace with context values.\n    /* XXX Right now this comes from page-js. Remove dependency. \n     */\n    parts = self.regexp.exec(self.path).slice(1);\n    \n    context = context || {};\n    \n    var replacePathPartWithContextValue = function (part, i) {\n      var re = new RegExp(part, \"g\"),\n          prop = part.replace(\":\", \"\"),\n          val;\n      \n      if (_.isObject(context))\n        val = context[prop]\n      else\n        val = args[i];\n      \n      path = path.replace(re, val || '');\n    };\n    \n    _.each(parts, replacePathPartWithContextValue);\n\n    return path;\n  }\n}());\n"]}