{"version":3,"file":"/packages/router.js","sources":["router/lib/router_server.js","router/lib/router_common.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,6B;;AAEA,iC;AACA,oD;AACA,Q;AACA,mC;AACA,C;;AAEA,sD;AACA,6C;AACA,Q;AACA,2C;AACA,C;;;AAGA,yB;AACA,oB;AACA,kB;AACA,qC;AACA,I;AACA,wB;AACA,E;;AAEA,0C;AACA,0D;AACA,kB;;AAEA,sC;AACA,qB;AACA,kB;AACA,G;;AAEA,+C;AACA,wC;AACA,4B;AACA,O;AACA,U;AACA,qB;AACA,qE;AACA,wB;AACA,oB;AACA,K;AACA,mC;AACA,oD;AACA,K;AACA,yE;AACA,G;AACA,E;;AAEA,sD;AACA,iD;AACA,6C;;AAEA,8D;AACA,uE;;AAEA,oB;AACA,qC;AACA,uC;;AAEA,2C;AACA,K;AACA,G;;AAEA,e;AACA,E;;AAEA,+C;AACA,oB;AACA,6F;AACA,G;;AAEA,gD;AACA,E;;AAEA,qC;AACA,kB;;AAEA,oB;AACA,uD;AACA,G;;AAEA,uB;;AAEA,wB;AACA,iB;AACA,6E;AACA,6D;AACA,mC;AACA,gE;AACA,+B;AACA,mE;;AAEA,wB;AACA,mD;;AAEA,+B;AACA,wB;AACA,gB;AACA,+D;;AAEA,yB;AACA,qE;AACA,kC;AACA,iE;AACA,qC;;AAEA,sC;AACA,mD;AACA,oD;AACA,0C;AACA,iB;AACA,a;;AAEA,sC;AACA,8C;AACA,a;;AAEA,+B;AACA,W;;AAEA,mC;AACA,oC;AACA,wB;AACA,W;;AAEA,iC;AACA,S;AACA,e;AACA,O;AACA,E;;AAEA,4B;AACA,6B;;;;;;;;;;;;;;;;;;;ACrIA,a;AACA,4D;AACA,I;AACA,iE;AACA,I;AACA,K;AACA,kE;AACA,+C;AACA,I;AACA,a;AACA,I;AACA,oD;AACA,mE;AACA,I;AACA,yB;AACA,2B;AACA,6B;AACA,iB;AACA,K;;AAEA,yD;AACA,4B;AACA,qB;AACA,yB;AACA,mC;AACA,sB;AACA,yB;AACA,wB;AACA,G;;AAEA,K;AACA,oE;AACA,uB;AACA,I;AACA,yB;AACA,2B;AACA,0B;AACA,sB;AACA,iB;AACA,K;;AAEA,uE;AACA,mC;AACA,I;AACA,0E;;AAEA,qB;AACA,gC;AACA,wD;AACA,mC;AACA,E;AACA,yB;;AAEA,mD;AACA,4B;;AAEA,uC;AACA,kC;AACA,e;;AAEA,gB;AACA,yD;AACA,4B;AACA,gB;AACA,c;AACA,yB;AACA,O;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,qC;AACA,oC;AACA,I;AACA,qC;AACA,uC;AACA,4C;AACA,yB;AACA,I;AACA,uC;AACA,yB;AACA,gC;AACA,6B;AACA,qB;AACA,iB;AACA,K;;AAEA,wD;AACA,4C;AACA,iE;AACA,e;AACA,iC;AACA,+B;AACA,iC;AACA,0G;AACA,wD;AACA,4B;AACA,iB;AACA,mC;AACA,iB;AACA,mC;AACA,qF;AACA,6B;AACA,Q;AACA,kC;AACA,mC;AACA,8B;AACA,I;AACA,8D;AACA,I;AACA,E;AACA,sB;AACA,E;AACA,kE;AACA,E;AACA,K;AACA,6E;AACA,gC;AACA,I;AACA,6E;AACA,I;AACA,2B;AACA,mE;AACA,kB;;AAEA,Y;AACA,yD;AACA,sD;AACA,4B;AACA,I;AACA,sE;AACA,oB;AACA,yB;AACA,c;AACA,yB;AACA,Q;AACA,yE;AACA,iE;AACA,O;AACA,iD;AACA,I;AACA,4B;AACA,I;AACA,8D;AACA,qC;AACA,uC;AACA,c;AACA,M;AACA,8B;AACA,2B;AACA,U;AACA,sB;AACA,M;AACA,yC;AACA,M;AACA,I;AACA,mD;;AAEA,gB;AACA,G;AACA,K","sourcesContent":["var connectHandlers, connect;\n\nif (typeof(Npm) == \"undefined\") {\n  connect = __meteor_bootstrap__.require(\"connect\");\n} else {\n  connect = Npm.require(\"connect\");\n}\n\nif (typeof __meteor_bootstrap__.app !== 'undefined') {\n  connectHandlers = __meteor_bootstrap__.app;\n} else {\n  connectHandlers = WebApp.connectHandlers;\n}\n\n\nvar Router = function() {\n  this._routes = [];\n  this._config = {\n    requestParser: connect.bodyParser\n  };\n  this._started = false;\n};\n\n// simply match this path to this function\nRouter.prototype.add = function(path, method, endpoint)  {\n  var self = this;\n\n  // Start serving on first add() call\n  if(!this._started){\n    this._start();\n  }\n\n  if (_.isObject(path) && ! _.isRegExp(path)) {\n    _.each(path, function(endpoint, p) {\n      self.add(p, endpoint);\n    });\n  } else {\n    if (! endpoint) {\n      // no http method was supplied so 2nd parameter is the endpoint\n      endpoint = method;\n      method = null;\n    }\n    if (! _.isFunction(endpoint)) {\n      endpoint = _.bind(_.identity, null, endpoint);\n    }\n    self._routes.push([new Meteor.Router.Route(path, method), endpoint]);\n  }\n};\n\nRouter.prototype.match = function(request, response) {\n  for (var i = 0; i < this._routes.length; i++) {\n    var params = [], route = this._routes[i];\n\n    if (route[0].match(request.url, request.method, params)) {\n      context = {request: request, response: response, params: params};\n\n      var args = [];\n      for (var key in context.params)\n        args.push(context.params[key]);\n\n      return route[1].apply(context, args);\n    }\n  }\n\n  return false;\n};\n\nRouter.prototype.configure = function(config) {\n  if(this._started){\n    throw new Error(\"Router.configure() has to be called before first call to Router.add()\");\n  }\n\n  this._config = _.extend(this._config, config);\n};\n\nRouter.prototype._start = function(){\n  var self = this;\n\n  if(this._started){\n    throw new Error(\"Router has already been started\");\n  }\n\n  this._started = true;\n\n  // hook up the serving\n  connectHandlers\n    .use(connect.query()) // <- XXX: we can probably assume accounts did this\n    .use(this._config.requestParser(this._config.bodyParser))\n    .use(function(req, res, next) {\n      // need to wrap in a fiber in case they do something async\n      // (e.g. in the database)\n      if(typeof(Fiber)==\"undefined\") Fiber = Npm.require('fibers');\n\n      Fiber(function() {\n        var output = Meteor.Router.match(req, res);\n\n        if (output === false) {\n          return next();\n        } else {\n          // parse out the various type of response we can have\n\n          // array can be\n          // [content], [status, content], [status, headers, content]\n          if (_.isArray(output)) {\n            // copy the array so we aren't actually modifying it!\n            output = output.slice(0);\n\n            if (output.length === 3) {\n              var headers = output.splice(1, 1)[0];\n              _.each(headers, function(value, key) {\n                res.setHeader(key, value);\n              });\n            }\n\n            if (output.length === 2) {\n              res.statusCode = output.shift();\n            }\n\n            output = output[0];\n          }\n\n          if (_.isNumber(output)) {\n            res.statusCode = output;\n            output = '';\n          }\n\n          return res.end(output);\n        }\n      }).run();\n    });\n};\n\n// Make the router available\nMeteor.Router = new Router();\n","(function() {\n  // Route object taken from page.js, slightly stripped down\n  //\n  // Copyright (c) 2012 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\n  //\n  /**\n   * Initialize `Route` with the given HTTP `path`, HTTP `method`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {String} method\n   * @param {Object} options.\n   * @api private\n   */\n\n  Meteor.Router.Route = function(path, method, options) {\n    options = options || {};\n    this.path = path;\n    this.method = method;\n    this.regexp = pathtoRegexp(path\n      , this.keys = []\n      , options.sensitive\n      , options.strict);\n  }\n\n  /**\n   * Check if this route matches `path` and optional `method`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {String} method\n   * @param {Array} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Meteor.Router.Route.prototype.match = function(path, method, params){\n    var keys, qsIndex, pathname, m;\n    \n    if (this.method && this.method.toUpperCase() !== method) return false;\n\n    keys = this.keys;\n    qsIndex = path.indexOf('?');\n    pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n    m = this.regexp.exec(pathname);\n  \n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n\n      var val = 'string' == typeof m[i]\n        ? decodeURIComponent(m[i])\n        : m[i];\n\n      if (key) {\n        params[key.name] = undefined !== params[key.name]\n          ? params[key.name]\n          : val;\n      } else {\n        params.push(val);\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Normalize the given path string,\n   * returning a regular expression.\n   *\n   * An empty array should be passed,\n   * which will contain the placeholder\n   * key names. For example \"/user/:id\" will\n   * then contain [\"id\"].\n   *\n   * @param  {String|RegExp|Array} path\n   * @param  {Array} keys\n   * @param  {Boolean} sensitive\n   * @param  {Boolean} strict\n   * @return {RegExp}\n   * @api private\n   */\n\n  function pathtoRegexp(path, keys, sensitive, strict) {\n    if (path instanceof RegExp) return path;\n    if (path instanceof Array) path = '(' + path.join('|') + ')';\n    path = path\n      .concat(strict ? '' : '/?')\n      .replace(/\\/\\(/g, '(?:/')\n      .replace(/\\+/g, '__plus__')\n      .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n        keys.push({ name: key, optional: !! optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n          + (optional || '');\n      })\n      .replace(/([\\/.])/g, '\\\\$1')\n      .replace(/__plus__/g, '(.+)')\n      .replace(/\\*/g, '(.*)');\n    \n    return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n  };\n  \n  /// END Route object\n  \n  // Added by tom, lifted from mini-pages, with some modifications\n  \n  /**\n    Given a context object, returns a url path with the values of the context\n    object mapped over the path.\n    \n    Alternatively, supply the named parts of the paths as discrete arguments.\n    \n    @method pathWithContext\n    @param [context] {Object} An optional context object to use for\n    interpolation.\n\n    @example\n        // given a page with a path of \"/posts/:_id/edit\"\n        var path = page.pathWithContext({ _id: 123 });\n        // > /posts/123/edit\n  */\n  Meteor.Router.Route.prototype.pathWithContext = function (context) {\n    var self = this,\n        path = self.path,\n        parts,\n        args = arguments;\n        \n    /* get an array of keys from the path to replace with context values.\n    /* XXX Right now this comes from page-js. Remove dependency. \n     */\n    parts = self.regexp.exec(self.path).slice(1);\n    \n    context = context || {};\n    \n    var replacePathPartWithContextValue = function (part, i) {\n      var re = new RegExp(part, \"g\"),\n          prop = part.replace(\":\", \"\"),\n          val;\n      \n      if (_.isObject(context))\n        val = context[prop]\n      else\n        val = args[i];\n      \n      path = path.replace(re, val || '');\n    };\n    \n    _.each(parts, replacePathPartWithContextValue);\n\n    return path;\n  }\n}());\n"]}