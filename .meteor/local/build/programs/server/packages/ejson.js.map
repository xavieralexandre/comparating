{"version":3,"file":"/packages/ejson.js","sources":["ejson/ejson.js","ejson/base64.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,W;AACA,e;;AAEA,qB;AACA,iE;AACA,+D;AACA,6C;AACA,8B;AACA,sE;AACA,qD;AACA,4D;AACA,sE;AACA,qD;AACA,E;AACA,0C;AACA,+B;AACA,yD;AACA,8B;AACA,E;;AAEA,yB;AACA,W;AACA,oC;AACA,sD;AACA,M;AACA,iC;AACA,iC;AACA,M;AACA,iC;AACA,oC;AACA,M;AACA,mC;AACA,iC;AACA,K;AACA,I;AACA,a;AACA,oC;AACA,wD;AACA,M;AACA,iC;AACA,2E;AACA,sD;AACA,M;AACA,iC;AACA,0C;AACA,M;AACA,mC;AACA,uC;AACA,K;AACA,I;AACA,yB;AACA,oC;AACA,wD;AACA,M;AACA,iC;AACA,8C;AACA,qB;AACA,O;AACA,4D;AACA,6C;AACA,S;AACA,M;AACA,iC;AACA,sB;AACA,yC;AACA,+C;AACA,S;AACA,+B;AACA,M;AACA,mC;AACA,sB;AACA,iD;AACA,iD;AACA,S;AACA,oB;AACA,K;AACA,I;AACA,a;AACA,oC;AACA,8E;AACA,M;AACA,iC;AACA,sC;AACA,M;AACA,iC;AACA,gE;AACA,M;AACA,mC;AACA,+B;AACA,4C;AACA,mC;AACA,K;AACA,G;AACA,E;;AAEA,sC;AACA,e;AACA,4C;AACA,yC;AACA,uC;AACA,E;;;AAGA,sD;AACA,4B;AACA,gD;AACA,mB;AACA,gB;AACA,4C;AACA,iC;AACA,wB;AACA,qC;AACA,yD;AACA,yB;AACA,2C;AACA,kB;AACA,yB;AACA,mC;AACA,K;AACA,4D;AACA,+B;AACA,kC;AACA,K;AACA,a;AACA,E;;AAEA,8E;AACA,sE;AACA,yC;AACA,sD;AACA,yC;AACA,sC;AACA,yC;AACA,K;AACA,G;AACA,mB;AACA,E;;AAEA,qC;AACA,wC;AACA,4B;AACA,mB;AACA,iC;AACA,6B;AACA,iC;AACA,G;AACA,c;AACA,E;;AAEA,sD;AACA,uD;AACA,6D;AACA,E;AACA,8B;AACA,kD;AACA,mB;AACA,gB;AACA,8C;AACA,2B;AACA,wB;AACA,qC;AACA,oC;AACA,+C;AACA,8B;AACA,2B;AACA,e;AACA,O;AACA,8D;AACA,iC;AACA,sC;AACA,K;AACA,K;AACA,a;AACA,E;;AAEA,0D;AACA,6D;;AAEA,uE;AACA,sB;AACA,4C;AACA,oD;AACA,0B;AACA,yC;AACA,iE;AACA,a;AACA,0D;AACA,6C;AACA,8C;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,uC;AACA,0C;AACA,qD;AACA,6B;AACA,mC;AACA,gB;AACA,U;AACA,mB;AACA,G;AACA,E;;AAEA,mC;AACA,iD;AACA,E;;AAEA,+B;AACA,+C;AACA,E;;AAEA,iC;AACA,+E;AACA,sC;AACA,E;;AAEA,yC;AACA,Q;AACA,mE;AACA,c;AACA,gB;AACA,4E;AACA,iB;AACA,wD;AACA,iB;AACA,6C;AACA,uC;AACA,+C;AACA,8B;AACA,mB;AACA,oC;AACA,wB;AACA,qB;AACA,K;AACA,gB;AACA,G;AACA,uC;AACA,gC;AACA,2B;AACA,8B;AACA,mB;AACA,8B;AACA,mB;AACA,oC;AACA,6C;AACA,qB;AACA,K;AACA,gB;AACA,G;AACA,gD;AACA,U;AACA,0B;AACA,mB;AACA,iC;AACA,sB;AACA,O;AACA,U;AACA,sC;AACA,8B;AACA,qB;AACA,O;AACA,2B;AACA,qB;AACA,O;AACA,qD;AACA,qB;AACA,O;AACA,U;AACA,kB;AACA,O;AACA,qC;AACA,U;AACA,U;AACA,wC;AACA,2B;AACA,qB;AACA,O;AACA,gD;AACA,qB;AACA,O;AACA,U;AACA,kB;AACA,O;AACA,kC;AACA,G;AACA,E;;AAEA,4B;AACA,U;AACA,4B;AACA,a;AACA,iB;AACA,4C;AACA,wB;AACA,iC;AACA,0B;AACA,oC;AACA,wC;AACA,oB;AACA,K;AACA,e;AACA,G;AACA,yC;AACA,+E;AACA,iB;AACA,a;AACA,kC;AACA,iC;AACA,e;AACA,G;AACA,0E;AACA,sC;AACA,qB;AACA,G;AACA,yB;AACA,W;AACA,mC;AACA,kC;AACA,K;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;ACrUA,mB;;AAEA,uF;;AAEA,sB;;AAEA,gD;AACA,4C;AACA,E;;AAEA,iC;AACA,kB;AACA,e;AACA,e;AACA,e;AACA,e;AACA,0C;AACA,oB;AACA,W;AACA,iC;AACA,iC;AACA,Y;AACA,W;AACA,oC;AACA,gC;AACA,Y;AACA,W;AACA,qC;AACA,0B;AACA,8B;AACA,8B;AACA,8B;AACA,8B;AACA,e;AACA,e;AACA,e;AACA,e;AACA,Y;AACA,K;AACA,G;AACA,kB;AACA,4B;AACA,4B;AACA,kB;AACA,uB;AACA,Q;AACA,8B;AACA,kB;AACA,uB;AACA,G;AACA,yB;AACA,E;;AAEA,8B;AACA,mC;AACA,E;;AAEA,4B;AACA,mB;AACA,c;AACA,G;AACA,0B;AACA,E;;AAEA,kC;AACA,gF;AACA,iB;AACA,mC;AACA,kB;AACA,K;AACA,mC;AACA,e;AACA,G;AACA,8C;AACA,E;;AAEA,+B;AACA,yC;AACA,0C;AACA,U;AACA,0C;AACA,Y;AACA,G;AACA,iC;;AAEA,iB;AACA,iB;AACA,mB;;AAEA,Y;;AAEA,wC;AACA,0B;AACA,sB;AACA,oB;AACA,W;AACA,gB;AACA,iD;AACA,mB;AACA,Y;AACA,W;AACA,gB;AACA,iD;AACA,2B;AACA,qB;AACA,4B;AACA,Y;AACA,W;AACA,mB;AACA,6B;AACA,uB;AACA,gC;AACA,O;AACA,Y;AACA,W;AACA,mB;AACA,6B;AACA,O;AACA,Y;AACA,K;AACA,G;AACA,a;AACA,E;;AAEA,sC;;AAEA,sC","sourcesContent":["EJSON = {};\nEJSONTest = {};\n\nvar customTypes = {};\n// Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A clone() method, so that Meteor can deep-copy it when necessary.\n// - A equals() method, so that Meteor can compare it\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n//\nEJSON.addType = function (name, factory) {\n  if (_.has(customTypes, name))\n    throw new Error(\"Type \" + name + \" already present\");\n  customTypes[name] = factory;\n};\n\nvar builtinConverters = [\n  { // Date\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$date') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return obj instanceof Date;\n    },\n    toJSONValue: function (obj) {\n      return {$date: obj.getTime()};\n    },\n    fromJSONValue: function (obj) {\n      return new Date(obj.$date);\n    }\n  },\n  { // Binary\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$binary') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\n        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));\n    },\n    toJSONValue: function (obj) {\n      return {$binary: base64Encode(obj)};\n    },\n    fromJSONValue: function (obj) {\n      return base64Decode(obj.$binary);\n    }\n  },\n  { // Escaping one level\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$escape') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      if (_.isEmpty(obj) || _.size(obj) > 2) {\n        return false;\n      }\n      return _.any(builtinConverters, function (converter) {\n        return converter.matchJSONValue(obj);\n      });\n    },\n    toJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj, function (value, key) {\n        newObj[key] = EJSON.toJSONValue(value);\n      });\n      return {$escape: newObj};\n    },\n    fromJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj.$escape, function (value, key) {\n        newObj[key] = EJSON.fromJSONValue(value);\n      });\n      return newObj;\n    }\n  },\n  { // Custom\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\n    },\n    matchObject: function (obj) {\n      return EJSON._isCustomType(obj);\n    },\n    toJSONValue: function (obj) {\n      return {$type: obj.typeName(), $value: obj.toJSONValue()};\n    },\n    fromJSONValue: function (obj) {\n      var typeName = obj.$type;\n      var converter = customTypes[typeName];\n      return converter(obj.$value);\n    }\n  }\n];\n\nEJSON._isCustomType = function (obj) {\n  return obj &&\n    typeof obj.toJSONValue === 'function' &&\n    typeof obj.typeName === 'function' &&\n    _.has(customTypes, obj.typeName());\n};\n\n\n// for both arrays and objects, in-place modification.\nvar adjustTypesToJSONValue =\nEJSON._adjustTypesToJSONValue = function (obj) {\n  if (obj === null)\n    return null;\n  var maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined)\n    return maybeChanged;\n  _.each(obj, function (value, key) {\n    if (typeof value !== 'object' && value !== undefined)\n      return; // continue\n    var changed = toJSONValueHelper(value);\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    }\n    // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\n// Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\nvar toJSONValueHelper = function (item) {\n  for (var i = 0; i < builtinConverters.length; i++) {\n    var converter = builtinConverters[i];\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n  return undefined;\n};\n\nEJSON.toJSONValue = function (item) {\n  var changed = toJSONValueHelper(item);\n  if (changed !== undefined)\n    return changed;\n  if (typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesToJSONValue(item);\n  }\n  return item;\n};\n\n// for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\n//\nvar adjustTypesFromJSONValue =\nEJSON._adjustTypesFromJSONValue = function (obj) {\n  if (obj === null)\n    return null;\n  var maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj)\n    return maybeChanged;\n  _.each(obj, function (value, key) {\n    if (typeof value === 'object') {\n      var changed = fromJSONValueHelper(value);\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\n// Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\nvar fromJSONValueHelper = function (value) {\n  if (typeof value === 'object' && value !== null) {\n    if (_.size(value) <= 2\n        && _.all(value, function (v, k) {\n          return typeof k === 'string' && k.substr(0, 1) === '$';\n        })) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n  return value;\n};\n\nEJSON.fromJSONValue = function (item) {\n  var changed = fromJSONValueHelper(item);\n  if (changed === item && typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesFromJSONValue(item);\n    return item;\n  } else {\n    return changed;\n  }\n};\n\nEJSON.stringify = function (item) {\n  return JSON.stringify(EJSON.toJSONValue(item));\n};\n\nEJSON.parse = function (item) {\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\nEJSON.isBinary = function (obj) {\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill));\n};\n\nEJSON.equals = function (a, b, options) {\n  var i;\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b)\n    return true;\n  if (!a || !b) // if either one is falsy, they'd have to be === to be equal\n    return false;\n  if (!(typeof a === 'object' && typeof b === 'object'))\n    return false;\n  if (a instanceof Date && b instanceof Date)\n    return a.valueOf() === b.valueOf();\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i])\n        return false;\n    }\n    return true;\n  }\n  if (typeof (a.equals) === 'function')\n    return a.equals(b, options);\n  if (a instanceof Array) {\n    if (!(b instanceof Array))\n      return false;\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options))\n        return false;\n    }\n    return true;\n  }\n  // fall back to structural equality of objects\n  var ret;\n  if (keyOrderSensitive) {\n    var bKeys = [];\n    _.each(b, function (val, x) {\n        bKeys.push(x);\n    });\n    i = 0;\n    ret = _.all(a, function (val, x) {\n      if (i >= bKeys.length) {\n        return false;\n      }\n      if (x !== bKeys[i]) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[bKeys[i]], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && i === bKeys.length;\n  } else {\n    i = 0;\n    ret = _.all(a, function (val, key) {\n      if (!_.has(b, key)) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[key], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && _.size(b) === i;\n  }\n};\n\nEJSON.clone = function (v) {\n  var ret;\n  if (typeof v !== \"object\")\n    return v;\n  if (v === null)\n    return null; // null has typeof \"object\"\n  if (v instanceof Date)\n    return new Date(v.getTime());\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n  if (_.isArray(v) || _.isArguments(v)) {\n    // For some reason, _.map doesn't work in this context on Opera (weird test\n    // failures).\n    ret = [];\n    for (i = 0; i < v.length; i++)\n      ret[i] = EJSON.clone(v[i]);\n    return ret;\n  }\n  // handle general user-defined typed Objects if they have a clone method\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  }\n  // handle other objects\n  ret = {};\n  _.each(v, function (value, key) {\n    ret[key] = EJSON.clone(value);\n  });\n  return ret;\n};\n","// Base 64 encoding\n\nvar BASE_64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvar BASE_64_VALS = {};\n\nfor (var i = 0; i < BASE_64_CHARS.length; i++) {\n  BASE_64_VALS[BASE_64_CHARS.charAt(i)] = i;\n};\n\nbase64Encode = function (array) {\n  var answer = [];\n  var a = null;\n  var b = null;\n  var c = null;\n  var d = null;\n  for (var i = 0; i < array.length; i++) {\n    switch (i % 3) {\n    case 0:\n      a = (array[i] >> 2) & 0x3F;\n      b = (array[i] & 0x03) << 4;\n      break;\n    case 1:\n      b = b | (array[i] >> 4) & 0xF;\n      c = (array[i] & 0xF) << 2;\n      break;\n    case 2:\n      c = c | (array[i] >> 6) & 0x03;\n      d = array[i] & 0x3F;\n      answer.push(getChar(a));\n      answer.push(getChar(b));\n      answer.push(getChar(c));\n      answer.push(getChar(d));\n      a = null;\n      b = null;\n      c = null;\n      d = null;\n      break;\n    }\n  }\n  if (a != null) {\n    answer.push(getChar(a));\n    answer.push(getChar(b));\n    if (c == null)\n      answer.push('=');\n    else\n      answer.push(getChar(c));\n    if (d == null)\n      answer.push('=');\n  }\n  return answer.join(\"\");\n};\n\nvar getChar = function (val) {\n  return BASE_64_CHARS.charAt(val);\n};\n\nvar getVal = function (ch) {\n  if (ch === '=') {\n    return -1;\n  }\n  return BASE_64_VALS[ch];\n};\n\nEJSON.newBinary = function (len) {\n  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\n    var ret = [];\n    for (var i = 0; i < len; i++) {\n      ret.push(0);\n    }\n    ret.$Uint8ArrayPolyfill = true;\n    return ret;\n  }\n  return new Uint8Array(new ArrayBuffer(len));\n};\n\nbase64Decode = function (str) {\n  var len = Math.floor((str.length*3)/4);\n  if (str.charAt(str.length - 1) == '=') {\n    len--;\n    if (str.charAt(str.length - 2) == '=')\n      len--;\n  }\n  var arr = EJSON.newBinary(len);\n\n  var one = null;\n  var two = null;\n  var three = null;\n\n  var j = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charAt(i);\n    var v = getVal(c);\n    switch (i % 4) {\n    case 0:\n      if (v < 0)\n        throw new Error('invalid base64 string');\n      one = v << 2;\n      break;\n    case 1:\n      if (v < 0)\n        throw new Error('invalid base64 string');\n      one = one | (v >> 4);\n      arr[j++] = one;\n      two = (v & 0x0F) << 4;\n      break;\n    case 2:\n      if (v >= 0) {\n        two = two | (v >> 2);\n        arr[j++] = two;\n        three = (v & 0x03) << 6;\n      }\n      break;\n    case 3:\n      if (v >= 0) {\n        arr[j++] = three | v;\n      }\n      break;\n    }\n  }\n  return arr;\n};\n\nEJSONTest.base64Encode = base64Encode;\n\nEJSONTest.base64Decode = base64Decode;\n"]}