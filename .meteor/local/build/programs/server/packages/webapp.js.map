{"version":3,"file":"/packages/webapp.js","sources":["webapp/webapp_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,8B;;AAEA,2B;AACA,+B;AACA,2B;AACA,+B;AACA,6B;AACA,mC;;AAEA,qC;AACA,uC;AACA,yC;AACA,+B;;AAEA,Y;AACA,qB;;AAEA,qC;AACA,mC;AACA,gB;AACA,kE;AACA,+D;AACA,oB;AACA,G;;AAEA,4C;AACA,G;;AAEA,oE;AACA,sE;AACA,Y;AACA,6E;AACA,qE;;AAEA,iC;AACA,yB;;AAEA,4C;AACA,uB;AACA,K;;AAEA,yB;;AAEA,2B;AACA,sB;AACA,8B;AACA,2D;AACA,sB;AACA,K;AACA,W;AACA,E;;;AAGA,gC;AACA,uC;AACA,wB;AACA,4B;AACA,E;;AAEA,yB;AACA,E;AACA,iE;AACA,kE;AACA,+C;AACA,E;AACA,wE;AACA,+D;AACA,sE;AACA,kE;AACA,W;AACA,E;AACA,kD;AACA,uE;AACA,E;AACA,uE;AACA,iE;AACA,gE;AACA,E;AACA,6D;AACA,qD;AACA,E;AACA,8E;AACA,8E;AACA,8E;AACA,sB;AACA,E;AACA,uE;AACA,qE;AACA,8C;AACA,E;AACA,mE;AACA,W;;;AAGA,yC;AACA,iC;AACA,8B;AACA,oC;AACA,4C;AACA,qE;AACA,G;AACA,wB;AACA,E;;AAEA,sC;AACA,8D;AACA,U;AACA,sC;AACA,4B;AACA,4B;AACA,2B;AACA,I;AACA,E;;AAEA,2C;AACA,U;AACA,kC;AACA,iC;AACA,I;AACA,E;;AAEA,8E;AACA,gF;AACA,sD;AACA,4B;AACA,mD;AACA,sB;AACA,oD;AACA,kC;AACA,0E;AACA,oC;AACA,K;AACA,6D;AACA,E;AACA,+C;AACA,gC;AACA,E;;AAEA,+B;AACA,6B;AACA,sD;AACA,iB;;AAEA,kE;AACA,kE;AACA,oE;AACA,oE;AACA,8D;AACA,kD;AACA,8B;AACA,iB;;AAEA,iE;AACA,gC;AACA,iB;;AAEA,wD;AACA,c;AACA,E;;AAEA,6E;AACA,wE;AACA,8D;AACA,kE;AACA,4B;AACA,6C;AACA,8C;AACA,wE;AACA,G;AACA,E;;AAEA,mC;AACA,wD;AACA,gE;AACA,yE;AACA,+C;AACA,uE;;AAEA,mD;AACA,8D;AACA,uD;;AAEA,6D;AACA,wE;AACA,qE;AACA,oB;AACA,wC;AACA,4D;AACA,6B;AACA,+B;AACA,yB;AACA,2B;AACA,8B;AACA,gC;;AAEA,gD;AACA,wE;AACA,kE;AACA,G;AACA,yE;AACA,yD;AACA,G;AACA,+E;;AAEA,c;AACA,sB;;AAEA,6C;AACA,8C;AACA,oE;AACA,oD;AACA,gC;AACA,6E;AACA,+D;AACA,gF;AACA,4C;AACA,mF;AACA,6D;AACA,a;AACA,2E;AACA,a;AACA,4B;AACA,8B;AACA,qC;AACA,qB;AACA,Y;AACA,a;AACA,K;AACA,K;AACA,0E;AACA,6B;AACA,2B;;AAEA,iD;AACA,8B;;AAEA,uB;AACA,+C;AACA,8C;AACA,mD;AACA,wB;AACA,kC;AACA,sC;AACA,uC;AACA,Q;;AAEA,2B;AACA,2E;AACA,qC;AACA,8D;AACA,+B;AACA,yB;AACA,U;AACA,O;AACA,K;AACA,K;;AAEA,0C;AACA,iD;AACA,qC;AACA,sD;AACA,a;AACA,a;AACA,K;AACA,wD;;AAEA,S;AACA,8C;AACA,iB;AACA,a;AACA,a;AACA,K;AACA,wC;AACA,a;AACA,a;AACA,K;;AAEA,8E;AACA,6E;AACA,c;;AAEA,qC;;AAEA,oE;AACA,gE;AACA,oC;AACA,M;AACA,+E;AACA,gF;AACA,oE;AACA,gF;AACA,4E;AACA,4E;AACA,kD;AACA,+B;AACA,qC;AACA,gC;;AAEA,oE;AACA,yE;AACA,sC;AACA,M;AACA,+E;AACA,+C;AACA,M;AACA,2E;AACA,c;AACA,kE;AACA,kE;AACA,kI;AACA,oE;AACA,uE;AACA,qE;AACA,8D;AACA,iE;AACA,sE;AACA,+D;AACA,M;AACA,2E;AACA,4E;AACA,M;AACA,8E;AACA,8C;AACA,4D;AACA,2E;AACA,wD;AACA,0B;AACA,sD;;AAEA,8C;AACA,qB;AACA,2E;AACA,mC;AACA,sD;AACA,2B;AACA,kB;AACA,Q;AACA,oC;AACA,uD;AACA,2B;AACA,kB;AACA,Q;AACA,iB;AACA,K;;AAEA,2E;AACA,kD;AACA,wC;AACA,iC;;AAEA,oC;AACA,+E;AACA,+E;AACA,mC;AACA,0C;AACA,6E;AACA,gB;AACA,a;AACA,K;AACA,gE;AACA,gC;AACA,K;;AAEA,8C;AACA,6B;AACA,qC;AACA,0B;AACA,oB;;AAEA,yB;AACA,yE;;AAEA,gD;;AAEA,qE;;AAEA,uE;AACA,mC;AACA,c;AACA,qB;AACA,K;;AAEA,gE;AACA,+B;AACA,uB;AACA,c;AACA,K;;;AAGA,0C;AACA,gC;;AAEA,iB;AACA,oB;AACA,2C;AACA,2B;AACA,sD;AACA,oB;AACA,mC;AACA,8E;AACA,oB;AACA,M;AACA,mB;AACA,wC;AACA,mC;AACA,M;AACA,+B;AACA,+B;AACA,qC;AACA,U;AACA,Y;AACA,M;AACA,2E;AACA,8E;AACA,6D;AACA,oC;AACA,K;AACA,+E;AACA,0D;AACA,kC;AACA,8B;AACA,K;;AAEA,2E;AACA,gF;AACA,2B;AACA,0B;AACA,oD;;AAEA,oE;AACA,qB;AACA,kD;AACA,e;AACA,gC;AACA,wC;AACA,0D;AACA,e;AACA,sC;AACA,8D;;AAEA,+D;AACA,sC;AACA,wC;AACA,4C;AACA,6E;AACA,iC;AACA,sD;AACA,2C;AACA,yD;AACA,mD;AACA,iC;AACA,sE;AACA,sB;AACA,kC;AACA,wE;AACA,6D;AACA,yD;AACA,yB;AACA,W;AACA,iD;AACA,6C;AACA,kF;AACA,kD;AACA,yD;AACA,+B;AACA,U;AACA,U;AACA,gC;AACA,2B;AACA,4B;AACA,W;AACA,O;;AAEA,2C;AACA,kC;AACA,+C;AACA,qB;AACA,2C;AACA,6B;AACA,Q;;AAEA,uB;AACA,sB;AACA,oB;AACA,I;AACA,E;;AAEA,sD;AACA,kD;AACA,sD;AACA,wD;AACA,yC;AACA,iC;AACA,6C;AACA,4B;AACA,wC;AACA,sC;AACA,8B;AACA,2C;AACA,8B;AACA,2C;AACA,8B;AACA,2C;;AAEA,uC;AACA,a;AACA,gC;AACA,wC;AACA,+B;AACA,I;AACA,6B;;AAEA,mB;AACA,sF;AACA,8B;AACA,I;;AAEA,kE;AACA,iB;AACA,qD;AACA,gC;AACA,iC;AACA,kC;AACA,yB;AACA,a;AACA,sB;AACA,c;AACA,iB;AACA,iB;AACA,+C;AACA,K;AACA,K;AACA,0B;AACA,a;AACA,a;AACA,iC;AACA,yB;AACA,gC;AACA,M;AACA,c;AACA,iB;AACA,iB;AACA,gC;AACA,K;AACA,K;AACA,wC;AACA,4B;AACA,e;AACA,e;AACA,mC;AACA,yB;AACA,mC;AACA,iB;AACA,Q;AACA,gB;AACA,mB;AACA,mB;AACA,kC;AACA,O;AACA,O;AACA,G;AACA,wB;AACA,E;;AAEA,kB","sourcesContent":["////////// Requires //////////\n\nvar fs = Npm.require(\"fs\");\nvar http = Npm.require(\"http\");\nvar os = Npm.require(\"os\");\nvar path = Npm.require(\"path\");\nvar url = Npm.require(\"url\");\nvar crypto = Npm.require(\"crypto\");\n\nvar connect = Npm.require('connect');\nvar optimist = Npm.require('optimist');\nvar useragent = Npm.require('useragent');\nvar send = Npm.require('send');\n\nWebApp = {};\nWebAppInternals = {};\n\nvar findGalaxy = _.once(function () {\n  if (!('GALAXY' in process.env)) {\n    console.log(\n      \"To do Meteor Galaxy operations like binding to a Galaxy \" +\n        \"proxy, the GALAXY environment variable must be set.\");\n    process.exit(1);\n  }\n\n  return DDP.connect(process.env['GALAXY']);\n});\n\n// Keepalives so that when the outer server dies unceremoniously and\n// doesn't kill us, we quit ourselves. A little gross, but better than\n// pidfiles.\n// XXX This should really be part of the boot script, not the webapp package.\n//     Or we should just get rid of it, and rely on containerization.\n\nvar initKeepalive = function () {\n  var keepaliveCount = 0;\n\n  process.stdin.on('data', function (data) {\n    keepaliveCount = 0;\n  });\n\n  process.stdin.resume();\n\n  setInterval(function () {\n    keepaliveCount ++;\n    if (keepaliveCount >= 3) {\n      console.log(\"Failed to receive keepalive! Exiting.\");\n      process.exit(1);\n    }\n  }, 3000);\n};\n\n\nvar sha1 = function (contents) {\n  var hash = crypto.createHash('sha1');\n  hash.update(contents);\n  return hash.digest('hex');\n};\n\n// #BrowserIdentification\n//\n// We have multiple places that want to identify the browser: the\n// unsupported browser page, the appcache package, and, eventually\n// delivering browser polyfills only as needed.\n//\n// To avoid detecting the browser in multiple places ad-hoc, we create a\n// Meteor \"browser\" object. It uses but does not expose the npm\n// useragent module (we could choose a different mechanism to identify\n// the browser in the future if we wanted to).  The browser object\n// contains\n//\n// * `name`: the name of the browser in camel case\n// * `major`, `minor`, `patch`: integers describing the browser version\n//\n// Also here is an early version of a Meteor `request` object, intended\n// to be a high-level description of the request without exposing\n// details of connect's low-level `req`.  Currently it contains:\n//\n// * `browser`: browser identification object described above\n// * `url`: parsed url, including parsed query params\n//\n// As a temporary hack there is a `categorizeRequest` function on WebApp which\n// converts a connect `req` to a Meteor `request`. This can go away once smart\n// packages such as appcache are being passed a `request` object directly when\n// they serve content.\n//\n// This allows `request` to be used uniformly: it is passed to the html\n// attributes hook, and the appcache package can use it when deciding\n// whether to generate a 404 for the manifest.\n//\n// Real routing / server side rendering will probably refactor this\n// heavily.\n\n\n// e.g. \"Mobile Safari\" => \"mobileSafari\"\nvar camelCase = function (name) {\n  var parts = name.split(' ');\n  parts[0] = parts[0].toLowerCase();\n  for (var i = 1;  i < parts.length;  ++i) {\n    parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].substr(1);\n  }\n  return parts.join('');\n};\n\nvar identifyBrowser = function (req) {\n  var userAgent = useragent.lookup(req.headers['user-agent']);\n  return {\n    name: camelCase(userAgent.family),\n    major: +userAgent.major,\n    minor: +userAgent.minor,\n    patch: +userAgent.patch\n  };\n};\n\nWebApp.categorizeRequest = function (req) {\n  return {\n    browser: identifyBrowser(req),\n    url: url.parse(req.url, true)\n  };\n};\n\n// HTML attribute hooks: functions to be called to determine any attributes to\n// be added to the '<html>' tag. Each function is passed a 'request' object (see\n// #BrowserIdentification) and should return a string,\nvar htmlAttributeHooks = [];\nvar htmlAttributes = function (template, request) {\n  var attributes = '';\n  _.each(htmlAttributeHooks || [], function (hook) {\n    var attribute = hook(request);\n    if (attribute !== null && attribute !== undefined && attribute !== '')\n      attributes += ' ' + attribute;\n  });\n  return template.replace('##HTML_ATTRIBUTES##', attributes);\n};\nWebApp.addHtmlAttributeHook = function (hook) {\n  htmlAttributeHooks.push(hook);\n};\n\n// Serve app HTML for this URL?\nvar appUrl = function (url) {\n  if (url === '/favicon.ico' || url === '/robots.txt')\n    return false;\n\n  // NOTE: app.manifest is not a web standard like favicon.ico and\n  // robots.txt. It is a file name we have chosen to use for HTML5\n  // appcache URLs. It is included here to prevent using an appcache\n  // then removing it from poisoning an app permanently. Eventually,\n  // once we have server side routing, this won't be needed as\n  // unknown URLs with return a 404 automatically.\n  if (url === '/app.manifest')\n    return false;\n\n  // Avoid serving app HTML for declared routes such as /sockjs/.\n  if (RoutePolicy.classify(url))\n    return false;\n\n  // we currently return app HTML on all URLs by default\n  return true;\n};\n\n// This is used to move legacy environment variables into deployConfig, where\n// other packages look for them. We probably don't want it here forever.\nvar copyEnvVarToDeployConfig = function (deployConfig, envVar,\n                                         packageName, configKey) {\n  if (process.env[envVar]) {\n    if (! deployConfig.packages[packageName])\n      deployConfig.packages[packageName] = {};\n    deployConfig.packages[packageName][configKey] = process.env[envVar];\n  }\n};\n\nvar runWebAppServer = function () {\n  // read the control for the client we'll be serving up\n  var clientJsonPath = path.join(__meteor_bootstrap__.serverDir,\n                                 __meteor_bootstrap__.configJson.client);\n  var clientDir = path.dirname(clientJsonPath);\n  var clientJson = JSON.parse(fs.readFileSync(clientJsonPath, 'utf8'));\n\n  if (clientJson.format !== \"browser-program-pre1\")\n    throw new Error(\"Unsupported format for client assets: \" +\n                    JSON.stringify(clientJson.format));\n\n  // XXX change all this config to something more reasonable.\n  //     and move it out of webapp into a different package so you don't\n  //     have weird things like mongo-livedata weak-dep'ing on webapp\n  var deployConfig =\n        process.env.METEOR_DEPLOY_CONFIG\n        ? JSON.parse(process.env.METEOR_DEPLOY_CONFIG) : {};\n  if (!deployConfig.packages)\n    deployConfig.packages = {};\n  if (!deployConfig.boot)\n    deployConfig.boot = {};\n  if (!deployConfig.boot.bind)\n    deployConfig.boot.bind = {};\n\n  // check environment for legacy env variables.\n  if (process.env.PORT && !_.has(deployConfig.boot.bind, 'localPort')) {\n    deployConfig.boot.bind.localPort = parseInt(process.env.PORT);\n  }\n  if (process.env.BIND_IP && !_.has(deployConfig.boot.bind, 'localIp')) {\n    deployConfig.boot.bind.localIp = process.env.BIND_IP;\n  }\n  copyEnvVarToDeployConfig(deployConfig, \"MONGO_URL\", \"mongo-livedata\", \"url\");\n\n  // webserver\n  var app = connect();\n\n  // Strip off the path prefix, if it exists.\n  app.use(function (request, response, next) {\n    var pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n    var url = Npm.require('url').parse(request.url);\n    var pathname = url.pathname;\n    // check if the path in the url starts with the path prefix (and the part\n    // after the path prefix must start with a / if it exists.)\n    if (pathPrefix && pathname.substring(0, pathPrefix.length) === pathPrefix &&\n       (pathname.length == pathPrefix.length\n        || pathname.substring(pathPrefix.length, pathPrefix.length + 1) === \"/\")) {\n      request.url = request.url.substring(pathPrefix.length);\n      next();\n    } else if (pathname === \"/favicon.ico\" || pathname === \"/robots.txt\") {\n      next();\n    } else if (pathPrefix) {\n      response.writeHead(404);\n      response.write(\"Unknown path\");\n      response.end();\n    } else {\n      next();\n    }\n  });\n  // Parse the query string into res.query. Used by oauth_server, but it's\n  // generally pretty handy..\n  app.use(connect.query());\n\n  // Auto-compress any json, javascript, or text.\n  app.use(connect.compress());\n\n  var staticFiles = {};\n  _.each(clientJson.manifest, function (item) {\n    if (item.url && item.where === \"client\") {\n      staticFiles[url.parse(item.url).pathname] = {\n        path: item.path,\n        cacheable: item.cacheable,\n        // Link from source to its map\n        sourceMapUrl: item.sourceMapUrl\n      };\n\n      if (item.sourceMap) {\n        // Serve the source map too, under the specified URL. We assume all\n        // source maps are cacheable.\n        staticFiles[url.parse(item.sourceMapUrl).pathname] = {\n          path: item.sourceMap,\n          cacheable: true\n        };\n      }\n    }\n  });\n\n  // Serve static files from the manifest.\n  // This is inspired by the 'static' middleware.\n  app.use(function (req, res, next) {\n    if ('GET' != req.method && 'HEAD' != req.method) {\n      next();\n      return;\n    }\n    var pathname = connect.utils.parseUrl(req).pathname;\n\n    try {\n      pathname = decodeURIComponent(pathname);\n    } catch (e) {\n      next();\n      return;\n    }\n    if (!_.has(staticFiles, pathname)) {\n      next();\n      return;\n    }\n\n    // We don't need to call pause because, unlike 'static', once we call into\n    // 'send' and yield to the event loop, we never call another handler with\n    // 'next'.\n\n    var info = staticFiles[pathname];\n\n    // Cacheable files are files that should never change. Typically\n    // named by their hash (eg meteor bundled js and css files).\n    // We cache them ~forever (1yr).\n    //\n    // We cache non-cacheable files anyway. This isn't really correct, as users\n    // can change the files and changes won't propagate immediately. However, if\n    // we don't cache them, browsers will 'flicker' when rerendering\n    // images. Eventually we will probably want to rewrite URLs of static assets\n    // to include a query parameter to bust caches. That way we can both get\n    // good caching behavior and allow users to change assets without delay.\n    // https://github.com/meteor/meteor/issues/773\n    var maxAge = info.cacheable\n          ? 1000 * 60 * 60 * 24 * 365\n          : 1000 * 60 * 60 * 24;\n\n    // Set the X-SourceMap header, which current Chrome understands.\n    // (The files also contain '//#' comments which FF 24 understands and\n    // Chrome doesn't understand yet.)\n    //\n    // Eventually we should set the SourceMap header but the current version of\n    // Chrome and no version of FF supports it.\n    //\n    // To figure out if your version of Chrome should support the SourceMap\n    // header,\n    //   - go to chrome://version. Let's say the Chrome version is\n    //      28.0.1500.71 and the Blink version is 537.36 (@153022)\n    //   - go to http://src.chromium.org/viewvc/blink/branches/chromium/1500/Source/core/inspector/InspectorPageAgent.cpp?view=log\n    //     where the \"1500\" is the third part of your Chrome version\n    //   - find the first revision that is no greater than the \"153022\"\n    //     number.  That's probably the first one and it probably has\n    //     a message of the form \"Branch 1500 - blink@r149738\"\n    //   - If *that* revision number (149738) is at least 151755,\n    //     then Chrome should support SourceMap (not just X-SourceMap)\n    // (The change is https://codereview.chromium.org/15832007)\n    //\n    // You also need to enable source maps in Chrome: open dev tools, click\n    // the gear in the bottom right corner, and select \"enable source maps\".\n    //\n    // Firefox 23+ supports source maps but doesn't support either header yet,\n    // so we include the '//#' comment for it:\n    //   https://bugzilla.mozilla.org/show_bug.cgi?id=765993\n    // In FF 23 you need to turn on `devtools.debugger.source-maps-enabled`\n    // in `about:config` (it is on by default in FF 24).\n    if (info.sourceMapUrl)\n      res.setHeader('X-SourceMap', info.sourceMapUrl);\n\n    send(req, path.join(clientDir, info.path))\n      .maxage(maxAge)\n      .hidden(true)  // if we specified a dotfile in the manifest, serve it\n      .on('error', function (err) {\n        Log.error(\"Error serving static file \" + err);\n        res.writeHead(500);\n        res.end();\n      })\n      .on('directory', function () {\n        Log.error(\"Unexpected directory \" + info.path);\n        res.writeHead(500);\n        res.end();\n      })\n      .pipe(res);\n  });\n\n  // Packages and apps can add handlers to this via WebApp.connectHandlers.\n  // They are inserted before our default handler.\n  var packageAndAppHandlers = connect();\n  app.use(packageAndAppHandlers);\n\n  var suppressConnectErrors = false;\n  // connect knows it is an error handler because it has 4 arguments instead of\n  // 3. go figure.  (It is not smart enough to find such a thing if it's hidden\n  // inside packageAndAppHandlers.)\n  app.use(function (err, req, res, next) {\n    if (!err || !suppressConnectErrors || !req.headers['x-suppress-error']) {\n      next(err);\n      return;\n    }\n    res.writeHead(err.status, { 'Content-Type': 'text/plain' });\n    res.end(\"An error message\");\n  });\n\n  // Will be updated by main before we listen.\n  var boilerplateHtml = null;\n  app.use(function (req, res, next) {\n    if (! appUrl(req.url))\n      return next();\n\n    if (!boilerplateHtml)\n      throw new Error(\"boilerplateHtml should be set before listening!\");\n\n    var request = WebApp.categorizeRequest(req);\n\n    res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});\n\n    var requestSpecificHtml = htmlAttributes(boilerplateHtml, request);\n    res.write(requestSpecificHtml);\n    res.end();\n    return undefined;\n  });\n\n  // Return 404 by default, if no other handlers serve this URL.\n  app.use(function (req, res) {\n    res.writeHead(404);\n    res.end();\n  });\n\n\n  var httpServer = http.createServer(app);\n  var onListeningCallbacks = [];\n\n  // start up app\n  _.extend(WebApp, {\n    connectHandlers: packageAndAppHandlers,\n    httpServer: httpServer,\n    // metadata about the client program that we serve\n    clientProgram: {\n      manifest: clientJson.manifest\n      // XXX do we need a \"root: clientDir\" field here? it used to be here but\n      // was unused.\n    },\n    // For testing.\n    suppressConnectErrors: function () {\n      suppressConnectErrors = true;\n    },\n    onListening: function (f) {\n      if (onListeningCallbacks)\n        onListeningCallbacks.push(f);\n      else\n        f();\n    },\n    // Hack: allow http tests to call connect.basicAuth without making them\n    // Npm.depends on another copy of connect. (That would be fine if we could\n    // have test-only NPM dependencies but is overkill here.)\n    __basicAuth__: connect.basicAuth\n  });\n  // XXX move deployConfig out of __meteor_bootstrap__, after deciding where in\n  // the world it goes. maybe a new deploy-config package?\n  _.extend(__meteor_bootstrap__, {\n    deployConfig: deployConfig\n  });\n\n  // Let the rest of the packages (and Meteor.startup hooks) insert connect\n  // middlewares and update __meteor_runtime_config__, then keep going to set up\n  // actually serving HTML.\n  main = function (argv) {\n    argv = optimist(argv).boolean('keepalive').argv;\n\n    var boilerplateHtmlPath = path.join(clientDir, clientJson.page);\n    boilerplateHtml =\n      fs.readFileSync(boilerplateHtmlPath, 'utf8')\n      .replace(\n        \"// ##RUNTIME_CONFIG##\",\n        \"__meteor_runtime_config__ = \" +\n          JSON.stringify(__meteor_runtime_config__) + \";\")\n      .replace(\n          /##ROOT_URL_PATH_PREFIX##/g,\n        __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\");\n\n    // only start listening after all the startup code has run.\n    var bind = deployConfig.boot.bind;\n    var localPort = bind.localPort || 0;\n    var localIp = bind.localIp || '0.0.0.0';\n    httpServer.listen(localPort, localIp, Meteor.bindEnvironment(function() {\n      if (argv.keepalive || true)\n        console.log(\"LISTENING\"); // must match run.js\n      var port = httpServer.address().port;\n      if (bind.viaProxy && bind.viaProxy.proxyEndpoint) {\n        WebAppInternals.bindToProxy(bind.viaProxy);\n      } else if (bind.viaProxy) {\n        // bind via the proxy, but we'll have to find it ourselves via\n        // ultraworld.\n        var galaxy = findGalaxy();\n        var proxyServiceName = deployConfig.proxyServiceName || \"proxy\";\n        galaxy.subscribe('servicesByName', proxyServiceName);\n        var Proxies = new Meteor.Collection('services', {\n          manager: galaxy\n        });\n        var doBinding = function (proxyService) {\n          if (proxyService.providers.proxy) {\n            Log(\"Attempting to bind to proxy at \" + proxyService.providers.proxy);\n            WebAppInternals.bindToProxy(_.extend({\n              proxyEndpoint: proxyService.providers.proxy\n            }, bind.viaProxy));\n         }\n        };\n        Proxies.find().observe({\n          added: doBinding,\n          changed: doBinding\n        });\n      }\n\n      var callbacks = onListeningCallbacks;\n      onListeningCallbacks = null;\n      _.each(callbacks, function (x) { x(); });\n    }, function (e) {\n      console.error(\"Error listening:\", e);\n      console.error(e.stack);\n    }));\n\n    if (argv.keepalive)\n      initKeepalive();\n    return 'DAEMON';\n  };\n};\n\nWebAppInternals.bindToProxy = function (proxyConfig) {\n  var securePort = proxyConfig.securePort || 4433;\n  var insecurePort = proxyConfig.insecurePort || 8080;\n  var bindPathPrefix = proxyConfig.bindPathPrefix || \"\";\n  // XXX also support galaxy-based lookup\n  if (!proxyConfig.proxyEndpoint)\n    throw new Error(\"missing proxyEndpoint\");\n  if (!proxyConfig.bindHost)\n    throw new Error(\"missing bindHost\");\n  // XXX move these into deployConfig?\n  if (!process.env.GALAXY_JOB)\n    throw new Error(\"missing $GALAXY_JOB\");\n  if (!process.env.GALAXY_APP)\n    throw new Error(\"missing $GALAXY_APP\");\n  if (!process.env.LAST_START)\n    throw new Error(\"missing $LAST_START\");\n\n  // XXX rename pid argument to bindTo.\n  var pid = {\n    job: process.env.GALAXY_JOB,\n    lastStarted: process.env.LAST_START,\n    app: process.env.GALAXY_APP\n  };\n  var myHost = os.hostname();\n\n  var ddpBindTo = {\n    ddpUrl: 'ddp://' + proxyConfig.bindHost + ':' + securePort + bindPathPrefix + '/',\n    insecurePort: insecurePort\n  };\n\n  // This is run after packages are loaded (in main) so we can use\n  // DDP.connect.\n  var proxy = DDP.connect(proxyConfig.proxyEndpoint);\n  var route = process.env.ROUTE;\n  var host = route.split(\":\")[0];\n  var port = +route.split(\":\")[1];\n  proxy.call('bindDdp', {\n    pid: pid,\n    bindTo: ddpBindTo,\n    proxyTo: {\n      host: host,\n      port: port,\n      pathPrefix: bindPathPrefix + '/websocket'\n    }\n  });\n  proxy.call('bindHttp', {\n    pid: pid,\n    bindTo: {\n      host: proxyConfig.bindHost,\n      port: insecurePort,\n      pathPrefix: bindPathPrefix\n    },\n    proxyTo: {\n      host: host,\n      port: port,\n      pathPrefix: bindPathPrefix\n    }\n  });\n  if (proxyConfig.securePort !== null) {\n    proxy.call('bindHttp', {\n      pid: pid,\n      bindTo: {\n        host: proxyConfig.bindHost,\n        port: securePort,\n        pathPrefix: bindPathPrefix,\n        ssl: true\n      },\n      proxyTo: {\n        host: host,\n        port: port,\n        pathPrefix: bindPathPrefix\n      }\n    });\n  }\n  Log(\"Bound to proxy\");\n};\n\nrunWebAppServer();\n"]}